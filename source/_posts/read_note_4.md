---
title: 博文阅读笔记 - 三月
date: 2017-03-28 18:30:42
tags: [NOTE]
category: [NOTE]
---
## 2017-3-28 新浪微博升级PHP7实践 
原文链接：[新浪微博升级PHP7](http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650994868&idx=1&sn=c79e0217ce2b3454c654fa9d90212d09&chksm=bdbf00e78ac889f11e65c4cbbcb9ea903b65422da93e61936e7badc828aa98d9df5460a0f3d7&scene=21#wechat_redirect)
原生的PHP，Zend引擎将php代码编译成opcode，再解释执行（执行C语言级的函数）。
HHVM替代了sZend引擎，PHP代码编译成字节码后，直接解释成机器的机器码执行。
![](http://7xrhmq.com1.z0.glb.clouddn.com/2017-03-28-14906944807555.jpg)

### 代码升级
1. 一些Fatal可以通过catch Error进行捕获。
2. 被0除，PHP7之前会产生WARNING并返回false，PHP7会返回+INF（正无穷），-INF（负无穷），INF（0/0）
3. 取模0时，PHP7之前产生WARNING，PHP7抛出 DivisionByZeroError 异常
4. 警告级别变更
![](http://7xrhmq.com1.z0.glb.clouddn.com/2017-03-28-14906967611663.jpg)

...其他参考原文

### 优化措施
1. 启用Opcache
2. 开启hugepage

>操作系统默认的内存是以4KB分页的，而虚拟地址和内存地址需要转换， 而这个转换要查表，CPU为了加速这个查表过程会内建TLB(Translation Lookaside Buffer)。 显然，如果虚拟页越小，表里的条目数也就越多，而TLB大小是有限的，条目数越多TLB的Cache Miss也就会越高， 所以如果我们能启用大内存页就能间接降低这个TLB Cache Miss。
>PHP7开启HugePage支持后，会把自身的text段, 以及内存分配中的huge都采用大内存页来保存, 减少TLB miss, 从而提高性能。相关实现可参考Opcache实现中的

## 2017-3-28 Redis架构之防雪崩设计
原文链接：[Redis架构之防雪崩设计](http://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug)
### 缓存穿透
当请求的数据在缓存层和存储层中都不存在时，会发生缓存穿透，请求流量直接打到存储层。缓存穿透时缓存失去对后端的保护作用，容易被攻击者利用。
缓存穿透的解决方法：
1. 缓存空对象
当从存储层读不到数据时，在缓存中写入空对象，下次请求时直接返回空对象。
这种方案的缺点是如果被攻击，会消耗大量的内存空间（存储空对象），这种情况下，可以给空值缓存的key设置过期时间来缓解。
2. 布隆过滤器
在redis之前加一层保护，定期更新一批存在的key。请求时，如果用布隆过滤器判断key不存在，则直接返回。
该方案的缺点是布隆过滤器的数据需要定期更新，在更新周期内可能存在数据不一致的情况。

### 雪崩
当缓存无法提供服务时，所有的请求流量都会到存储层，存储层压力暴增，造成存储层不可用进而影响其他系统。
雪崩主要通过服务隔离、服务限流、服务降级、灾备演练等方法避免。
### 热点Key优化
一般缓存的key都存在失效失效时间，当热点key（并发请求量大）失效时，如果重建缓存的过程比较复杂（如多个SQL、多个依赖、逻辑复杂），大量服务器资源用于重建缓存，造成后端负载过大。
热点key优化的方法：
1. 重建缓存过程加锁
当某个进程发现key失效时，该进程对该key进行加锁（如setnx）后进入重建逻辑，其他进程请求该key的进程进入等待。
这种方法的缺点很明显，有可能造成死锁或者大量进程的等待。
2. 逻辑上控制失效时间
在redis中不设置key的失效时间，业务逻辑上控制失效，当发现key失效时，发起一个异步重建的任务。
这种方法的缺点是在重建这段时间存在数据不一致，优点是能大大降低热点key失效时的负载（实际上相当于该key在redis中永远不会失效）。


